import logging
import asyncio
import keyboard
import argparse
from crewai import Crew, Flow, LLM
from tasks import TaskCreator
from utils import CustomCrawler
from pydantic import BaseModel, ValidationError
from crewai.flow.flow import listen, start, and_, or_, router
from typing import Optional


# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ResponseState(BaseModel):
    """
    State model for managing conversation flow.
    Attributes:
        user_input (str): The input query from the user
        agent_response (str): The response generated by the agent
    """
    user_input: str = ""
    agent_response: str = ""

class CreateCrew(Flow[ResponseState]):
    """
    Main flow controller for creating and managing different crews of agents.
    This class orchestrates the interaction between different specialized crews
    including routing, retrieval, and response checking.
    """
    
    def __init__(self):
        """Initialize the flow controller and task creator."""
        try:
            super().__init__()
            self.task_creator = TaskCreator()
        except Exception as e:
            logger.error(f"Failed to initialize CreateCrew: {str(e)}")
            raise

    def router_crew(self) -> Crew:
        """
        Create a crew responsible for routing queries to appropriate handlers.
        Returns:
            Crew: Configured routing crew
        Raises:
            ValueError: If agent or task creation fails
        """
        try:
            return Crew(
                agents=[self.task_creator.router_agent()],
                tasks=[self.task_creator.router_task()],
                verbose=True,
            )
        except Exception as e:
            logger.error(f"Failed to create router crew: {str(e)}")
            raise ValueError(f"Router crew creation failed: {str(e)}")

    def retriever_crew(self) -> Crew:
        """
        Create a crew responsible for retrieving information.
        Returns:
            Crew: Configured retriever crew
        Raises:
            ValueError: If agent or task creation fails
        """
        try:
            return Crew(
                agents=[self.task_creator.retriever_agent()],
                tasks=[self.task_creator.retriever_task()],
                verbose=True,
            )
        except Exception as e:
            logger.error(f"Failed to create retriever crew: {str(e)}")
            raise ValueError(f"Retriever crew creation failed: {str(e)}")

    def checking_crew(self) -> Crew:
        """
        Create a crew responsible for validating and grading responses.
        Combines grader, hallucination checker, and answer validator agents.
        Returns:
            Crew: Configured checking crew
        Raises:
            ValueError: If agent or task creation fails
        """
        try:
            return Crew(
                agents=[
                    self.task_creator.grader_agent(),
                    self.task_creator.hallucination_grader_agent(),
                    self.task_creator.answer_grader_agent()
                ],
                tasks=[
                    self.task_creator.grader_task(),
                    self.task_creator.hallucination_grader_task(),
                    self.task_creator.answer_grader_task()
                ],
                verbose=True,
            )
        except Exception as e:
            logger.error(f"Failed to create checking crew: {str(e)}")
            raise ValueError(f"Checking crew creation failed: {str(e)}")

    @start()
    def input_query(self) -> str:
        """
        Initial method to process and validate the input query.
        Returns:
            str: Validated query string
        Raises:
            ValueError: If query is empty or invalid
        """
        try:
            query = self.state.user_input.strip()
            if not query:
                raise ValueError("Query cannot be empty")
            
            logger.info(f"Processing query: {query}")
            return query
            
        except Exception as e:
            logger.error(f"Error processing input query: {str(e)}")
            raise

    @router(input_query)
    def route_query(self) -> str:
        """
        Route the input query to appropriate handler based on content.
        Returns:
            str: Raw response from router crew
        Raises:
            ValueError: If routing fails
        """
        try:
            inputs_route = {"question": self.state.user_input}
            response_route = self.router_crew().kickoff(inputs=inputs_route)
            return response_route.raw
            
        except Exception as e:
            logger.error(f"Error in query routing: {str(e)}")
            raise ValueError(f"Query routing failed: {str(e)}")

    @listen("VECTORSEARCH")
    def retrieve_info(self) -> str:
        """
        Retrieve information based on the query using vector search.
        Returns:
            str: Retrieved and processed information
        Raises:
            ValueError: If retrieval fails
        """
        try:
            inputs_ret = {"question": self.state.user_input}
            response_ret = self.retriever_crew().kickoff(inputs=inputs_ret)
            
            response_ret = response_ret.raw
            self.state.agent_response = response_ret
            
            return response_ret
            
        except Exception as e:
            logger.error(f"Error in information retrieval: {str(e)}")
            raise ValueError(f"Information retrieval failed: {str(e)}")

    @router(retrieve_info)
    def post_processing(self) -> str:
        """
        Process and validate the retrieved information.
        Returns:
            str: Processed and validated response
        Raises:
            ValueError: If post-processing fails
        """
        try:
            inputs_process = {
                "question": self.state.user_input,
                "response": self.state.agent_response
            }
            response_process = self.checking_crew().kickoff(inputs=inputs_process)
            return response_process.raw
            
        except Exception as e:
            logger.error(f"Error in post-processing: {str(e)}")
            raise ValueError(f"Response post-processing failed: {str(e)}")


if __name__ == '__main__':
    try:
        run = CreateCrew()

        parser = argparse.ArgumentParser()
        parser.add_argument("--url", type=str, required=True, help="Website URL")
        args = parser.parse_args()
        url = args.url

        crawler_tool = CustomCrawler()
        depth = 1
        asyncio.run(crawler_tool.scrapper_tool(url, depth))

        while True:
            inp_qu = input("Enter the Question : ")
            run.state.user_input = inp_qu
            result = run.kickoff()
            # run.plot("my_flow_plot")

            print(result)
            if keyboard.is_pressed("esc"):
                print("ESC pressed. Exiting...")
                break
        
    except ValidationError as e:
        logger.error(f"Validation error: {str(e)}")
        print("Invalid input or state configuration")
        
    except ValueError as e:
        logger.error(f"Value error: {str(e)}")
        print(f"Error processing request: {str(e)}")
        
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        print("An unexpected error occurred")